---
title: Usage
description: Understand the basics for connecting to Basin and using object stores.
---

The most basic usage will likely involve connecting to the network, creating an object store, and then adding or getting
objects. This page walks through each step and provides examples to help you get started.

## Signer & provider setup

To create an object store, you'll need to use the `JsonRpcProvider` from the `adm_provider` crate plus various `adm_sdk`
types.

Here's a simple example. The `signer.init_sequence` call is optional, but without it, you'll run into issues with out of
sync sequences (nonces). **It's best to call `init_sequence` unless you're firing many transactions at once.**

```rust
use adm_provider::json_rpc::JsonRpcProvider;
use adm_sdk::{
    machine::{objectstore::ObjectStore, Machine},
    network::Network,
};
use fendermint_actor_machine::WriteAccess;

#[tokio::main]
async fn main() {
    let network = Network::Testnet.init();
    let provider =
        JsonRpcProvider::new_http(network.rpc_url()?, None, Some(network.object_api_url()?))?;
    let file = async_tempfile::TempFile::new().await?;

    signer.init_sequence(&provider).await?;
}
```

## Creating an object store

To create an object store, you'll need to use the `ObjectStore::new` method, which takes a provider, signer, desired
write access controls, and custom gas parameters. Currently, only two `WriteAccess` options are available: `OnlyOwner`
or `Public`.

```rust
async fn main() {
    // Existing code...

    let (os, tx) = ObjectStore::new(
        &provider,
        &mut signer,
        WriteAccess::OnlyOwner,
        Default::default(),
    ).await?;
}
```

Note the second value returned is the onchain transaction that created the object store.

## Adding an object

We can extend the example above to add an object to the object store. The `add` method is used to add an object to the
object store given a provider, signer, the object's desired key (e.g., `my/key`), and options that control its behavior.
For example, you can add other metadata to an object or specify how to handle overwriting an existing object.

```rust {3}
use adm_sdk::{
    machine::{
        objectstore::{AddOptions, ObjectStore},
        Machine,
    },
    network::Network,
};
use tokio::io::{AsyncSeekExt, AsyncWriteExt};

async fn main() {
    // Existing code...

    let file = async_tempfile::TempFile::new().await?;
    file.write_all("hello world".as_bytes()).await?;
    file.flush().await?;
    file.rewind().await?;

    let key = "my/key".to_string();
    let mut metadata = std::collections::HashMap::new();
    metadata.insert("foo".to_string(), "bar".to_string());
    let options = AddOptions {
        overwrite: true,
        metadata,
        ..Default::default()
    };
    let tx = os
        .add(&provider, &mut signer, &key, file, Default::default())
        .await?;
}
```

For reference, a transaction includes the status, hash, height, gas used, and the CID.

```json
{
  "status": "committed",
  "hash": "D09C9563A16CFBAF9323DE83FCE795D17D20F16DFC543E8593CD13997ED0B04C",
  "height": "1127838",
  "gas_used": 5484543,
  "data": "bafy2bzacedxeu3g3uazqpn2ln7yvyfhc6ilj3vi5bf3h6usvygsxaub7paws4"
}
```

## Querying objects

To list an object, you can use the `query` method. This method comes with available query options to refine your
results:

- `prefix`: The prefix of the keys you want to list.
- `delimiter`: The delimiter to use when listing keys.
- `offset`: The offset to start listing keys.
- `limit`: The maximum number of keys to list.
- `height`: The height of the object store to list keys from (defaults to the latest committed height).

```rust {3}
use adm_sdk::{
    machine::{
        objectstore::{AddOptions, ObjectStore, QueryOptions},
        Machine,
    },
    network::Network,
};

async fn main() {
    // Existing code...

    let options = QueryOptions {
        prefix: "my/".to_string(),
        delimiter: "/".to_string(),
        offset: 0,
        limit: req.limit.unwrap_or_default(),
        height: Default::default(),
    };
    let list = os.query(&provider, options).await?;
}
```

This will give you a list of all objects and any other common prefixes down the tree.

```json
{
  "common_prefixes": [],
  "objects": [
    {
      "key": "my/key",
      "value": {
        "cid": "bafybeid3weurg3gvyoi7nisadzolomlvoxoppe2sesktnpvdve3256n5tq",
        "metadata": {},
        "resolved": true,
        "size": 5
      }
    }
  ]
}
```

## Getting an object

You can use the `get` method to retrieve data and download the actual contents. A few options are available to refine
your results:

- `bytes`: Range request bytes as a dash-separated string (e.g., `"0-99"` gets the first 100 bytes).
- `height`: The height of the object store to list keys from (defaults to the latest committed height).
- `show_progress`: Visually show the download progress (useful with CLI tools).

```rust {3}
use adm_sdk::{
    machine::{
        objectstore::{AddOptions, GetOptions, ObjectStore, QueryOptions},
        Machine,
    },
    network::Network,
};

async fn main() {
    // Existing code...

    let options = GetOptions {
        range: Some("0-99".to_string()), // Get the first 100 bytes
        ..Default::default()
    };

    let file = async_tempfile::TempFile::new().await?;
    {
        let open_file = file.open_rw().await?;
        machine.get(&provider, &key, open_file, options).await?;
    }
    // Read the first 10 bytes of your downloaded 100 bytes
    let mut read_file = tokio::fs::File::open(&obj_path).await?;
    let mut contents = vec![0; 10];
    read_file.read(&mut contents).await?;
}
```

## Deleting an object

Lastly, since Basin is a fully mutable store, you can delete an object using the `delete` method. It takes similar
parameters as adding an object. The default options are generally used, which let you specify the broadcast mode and gas
parameters.

```rust
async fn main() {
    // Existing code...

    let tx = machine
        .delete(&provider, &mut signer, &key, Default::default())
        .await?;
}
```

The response will be similar to the `add` example above.

## Network interactions

You can review the `adm_sdk::network` module for more information or check out the network configuration docs. Utility
methods exist on the `adm_sdm::network::Network` struct to fetch network values dynamically, so there's not necessarily
a need to hardcode them yourself anywhere.

For example, you'll notice the subnet ID has a string value. Its hex encoded value can be found with an RPC call to the
EVM provider URL:

```sh copy
curl https://evm-api.n1.testnet.basin.storage \
-X POST \
-H "Content-Type: application/json" \
-d '{"method":"eth_chainId","params":[],"id":1,"jsonrpc":"2.0"}'
```

You can use these values in any wallet configuration, such as MetaMask, to interact with the subnet directly!
